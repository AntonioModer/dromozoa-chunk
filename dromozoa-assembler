#! /usr/bin/env lua

-- Copyright (C) 2015 Tomoyuki Fujimori <moyu@dromozoa.com>
--
-- This file is part of dromozoa-assembler.
--
-- dromozoa-assembler is free software: you can redistribute it and/or modify
-- it under the terms of the GNU General Public License as published by
-- the Free Software Foundation, either version 3 of the License, or
-- (at your option) any later version.
--
-- dromozoa-assembler is distributed in the hope that it will be useful,
-- but WITHOUT ANY WARRANTY; without even the implied warranty of
-- MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
-- GNU General Public License for more details.
--
-- You should have received a copy of the GNU General Public License
-- along with dromozoa-assembler.  If not, see <http://www.gnu.org/licenses/>.

local json = require "dromozoa.json"

local is_little_endian = true
local sizeof_int = 4
local sizeof_integer = 8
local sizeof_size_t = 8

local function reader(handle)
  local self = {
    _handle = handle;
  }

  function self:read_byte()
    return self._handle:read(1):byte()
  end

  function self:read_integer_impl(n)
    local buffer = { self._handle:read(n):byte(1, -1) }
    -- byte swap
    local v = 0
    for i = #buffer, 1, -1 do
      v = v * 256
      v = v + buffer[i]
    end
    return v
  end

  function self:read_int()
    return self:read_integer_impl(sizeof_int)
  end

  function self:read_integer()
    return self:read_integer_impl(sizeof_integer)
  end

  function self:read_size_t()
    return self:read_integer_impl(sizeof_size_t)
  end

  function self:read_instruction()
    return { self._handle:read(4):byte(1, -1) }
  end

  function self:read_string()
    local n = self:read_byte()
    if n == 0 then
      return nil
    elseif n == 255 then
      n = self:read_size_t()
    end
    return self._handle:read(n - 1)
  end

  function self:check_eof()
    local v = self._handle:read(1)
    assert(v == nil)
  end

  function self:check_literal(literal)
    local v = self._handle:read(#literal)
    assert(v)
    return v
  end

  function self:read_header()
    local header = {}

    header.LUA_SIGNATURE = self:check_literal("\27Lua")
    local version = self:read_byte()
    header.LUAC_VERSION = {
      LUAC_VERSION = version;
      LUA_VERSION_MAJOR = math.floor(version / 16);
      LUA_VERSION_MINOR = version % 16;
    }
    header.LUAC_FORMAT = self:read_byte()
    self:check_literal("\25\147\r\n\26\n") -- not UTF-8
    header["sizeof(int)"] = self:read_byte()
    header["sizeof(size_t)"] = self:read_byte()
    header["sizeof(Instruction)"] = self:read_byte()
    header["sizeof(lua_Integer)"] = self:read_byte()
    header["sizeof(lua_Number)"] = self:read_byte()
    header.LUAC_INT = self:read_integer()
    header.LUAC_NUM = { self._handle:read(8):byte(1, -1) }
    return header
  end

  function self:read_code()
    local code = {}
    local n = self:read_int()
    for i = 1, n do
      code[i] = self:read_instruction()
    end
    return code
  end

  function self:read_constants()
    local constants = {}
    local n = self:read_int()
    for i = 1, n do
      local t = self:read_byte()
      if t == 0 then -- LUA_TNIL
        constants[i] = nil
      elseif t == 1 then -- LUA_TBOOLEAN
        constants[i] = self:read_byte() ~= 0
      elseif t == 3 then -- LUA_TNUMFLT
        constants[i] = { self._handle:read(8):byte(1, -1) }
      elseif t == 19 then -- LUA_TNUMINT
        constants[i] = self:read_integer()
      elseif t == 4 or t == 20 then -- LUA_STRING
        constants[i] = self:read_string()
      end
    end
    return constants
  end

  function self:read_upvalues()
    local upalues = {}
    local n = self:read_int()
    for i = 1, n do
      local instack = self:read_byte()
      local idx = self:read_byte()
      upalues[i] = { instack = instack; idx = idx }
    end
    return upalues
  end

  function self:read_protos()
    local protos = {}
    local n = self:read_int()
    for i = 1, n do
      protos[i] = self:read_function()
    end
    return protos
  end

  function self:read_debug()
    local debug = {
      lineinfo = {};
      localvars = {};
      upvalues = {};
    }
    local n = self:read_int()
    for i = 1, n do
      debug.lineinfo[i] = self:read_int()
    end
    local n = self:read_int()
    for i = 1, n do
      local varname = self:read_string()
      local startpc = self:read_int()
      local endpc = self:read_int()
      debug.localvars[i] = { varname = varname; startpc = startpc; endpc = endpc }
    end
    local n = self:read_int()
    for i = 1, n do
      local name = self:read_string()
      debug.upvalues = { name = name }
    end
  end

  function self:read_function()
    local closure = {}

    closure.source = self:read_string()
    closure.linedefined = self:read_int()
    closure.lastlinedefined = self:read_int()
    closure.numparams = self:read_byte()
    closure.is_vaarg = self:read_byte()
    closure.maxstacksize = self:read_byte()
    closure.code = self:read_code()
    closure.constants = self:read_constants()
    closure.upvalues = self:read_upvalues()
    closure.protos = self:read_protos()
    closure.debug = self:read_debug()

    return closure
  end

  return self
end

local r = reader(io.stdin)
local header = r:read_header()
print(json.encode(header))
local sizeupvalues = r:read_byte()
print(sizeupvalues)
local closure = r:read_function()
print(json.encode(closure))
r:check_eof()
